/**
 * demo 程序的运行环境是 Linux 操作系统，用的多线程编程
 * 
 * ===========================================================
 *                          文件结构
 * ===========================================================
 * 
 * spp_def.h
 * -----------------------------------
 * 这个文件定义了协议栈需要用到的宏，包括打印程序运行信息的宏开关 DEBUG_PRINTF 以及
 * 变量类型定义以及常量定义
 * 
 * 
 * spp_gloabl.h
 * -----------------------------------
 * 这个文件定义了协议栈需要用到的全局变量
 * 
 * 
 * spp_include.h
 * -----------------------------------
 * 这个文件包含了所有的头文件
 * 
 * 
 * spp_interface.c
 * ----------------------------------
 * 协议栈向应用暴露的接口，这个文件中的 SendMessage() 和 RecvMessage() 可根据实
 * 际的message结构做修改，只要保证调用传递给 LLC 层的数据满足 LLC 向上暴露接口的条
 * 件即可
 * 
 * 
 * spp_connect.c
 * ----------------------------------
 * 三次握手状态机，负责处理三次握手过程中的连接命令帧
 * 
 * 
 * spp_LLC.c
 * ----------------------------------
 * LLC 层，负责把消息分片成一帧一帧的 LLC 帧放到待发送队列链表中，以及把接收到的一个个
 * LLC 分片组装成一条完整的 message
 * 
 * 
 * spp_MAC.c
 * ---------------------------------- 
 * MAC 层，负责把一帧 LLC 帧封装成 MAC 帧，然后调用底层的发送函数发送出去。以及把从
 * 底层硬件那里读到的字节流解析成一帧 MAC 帧，并校验，把无错的 LLC 帧解析出来递交给
 * LLC 层（读缓冲区）
 * 
 * 
 * spp_multiTimer.c
 * ----------------------------------
 * 一个多时钟任务管理，通过一个时钟产生定时信号，处理这个定时信号用于产生多时钟任务，
 * 向外暴露的接口在源文件中有说明。如果硬件可以产生多个时钟信号，也可以作相应修改。
 * 这里这样做是因为 demo 的 linux 运行环境中一个进程下只能有一个定时器。
 * 
 * 
 * spp_porting.c
 * ---------------------------------
 * 修改文件中的发送和接收函数为实际调用的 SPI 收发接口，demo 采用的 UDP 通信。
 * 
 * 
 * =================================================================
 *                          软件执行流程
 * =================================================================
 * 
 * 对于 MCU 没有多线程的情况，可以使用多任务，如果没有多任务，可以采用分时复用，将
 * 5 毫秒作为一个并行执行时间片，在这个时间皮中分时分别处理五个任务。
 * 
 * 协议栈自身有四个线程，
 *          主线程：初始化，等待别的线程结束
 *          读线程：不停的从硬件读数据
 *          写线程：不停检查发送队列链表，有数据则发送
 *          时钟线程：提供多时钟功能
 * 
 * 应用则作为服务器线程或者是客户端线程，收发应用数据
 * 
 * 当初始化完成，则应该启动协议栈的四个线程
 * 
 * 详细的数据变化参考软件栈设计概要初稿中的数据变化图
*/